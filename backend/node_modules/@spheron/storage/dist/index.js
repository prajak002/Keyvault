"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DomainTypeEnum: () => import_core.DomainTypeEnum,
  IPNSName: () => import_core2.IPNSName,
  ProtocolEnum: () => import_core2.ProtocolEnum,
  SpheronClient: () => SpheronClient,
  TokenScope: () => import_core2.TokenScope,
  UploadStatusEnum: () => UploadStatusEnum,
  UsageWithLimits: () => import_core2.UsageWithLimits,
  default: () => src_default,
  ipfs: () => ipfs
});
module.exports = __toCommonJS(src_exports);

// src/bucket-manager/index.ts
var import_core = require("@spheron/core");

// src/bucket-manager/interfaces.ts
var UploadStatusEnum = /* @__PURE__ */ ((UploadStatusEnum2) => {
  UploadStatusEnum2["PENDING"] = "Pending";
  UploadStatusEnum2["CANCELED"] = "Canceled";
  UploadStatusEnum2["DEPLOYED"] = "Deployed";
  UploadStatusEnum2["FAILED"] = "Failed";
  UploadStatusEnum2["TIMED_OUT"] = "TimedOut";
  return UploadStatusEnum2;
})(UploadStatusEnum || {});

// src/bucket-manager/index.ts
var BucketManager = class {
  constructor(spheronApi) {
    this.spheronApi = spheronApi;
  }
  getBucket(bucketId) {
    return __async(this, null, function* () {
      const project = yield this.spheronApi.getProject(bucketId);
      if (project.type !== import_core.ProjectTypeEnum.UPLOAD) {
        throw new Error(`Project with id '${bucketId}' is not a bucket.`);
      }
      return this.mapProjectToBucket(project);
    });
  }
  getBucketDomains(bucketId) {
    return __async(this, null, function* () {
      const { domains } = yield this.spheronApi.getProjectDomains(bucketId);
      return domains.map((x) => this.mapProjectDomainToBucketDomain(x));
    });
  }
  getBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      const { domain } = yield this.spheronApi.getProjectDomain(
        bucketId,
        domainIdentifier
      );
      return this.mapProjectDomainToBucketDomain(domain);
    });
  }
  updateBucketDomain(bucketId, domainIdentifier, options) {
    return __async(this, null, function* () {
      const { domain } = yield this.spheronApi.patchProjectDomain(
        bucketId,
        domainIdentifier,
        __spreadProps(__spreadValues({}, options), { deploymentEnvironments: [] })
      );
      return this.mapProjectDomainToBucketDomain(domain);
    });
  }
  verifyBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      const { domain } = yield this.spheronApi.verifyProjectDomain(
        bucketId,
        domainIdentifier
      );
      return this.mapProjectDomainToBucketDomain(domain);
    });
  }
  deleteBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      yield this.spheronApi.deleteProjectDomain(bucketId, domainIdentifier);
    });
  }
  addBucketDomain(bucketId, options) {
    return __async(this, null, function* () {
      const { domain } = yield this.spheronApi.addProjectDomain(bucketId, __spreadProps(__spreadValues({}, options), {
        deploymentEnvironments: []
      }));
      return this.mapProjectDomainToBucketDomain(domain);
    });
  }
  getBucketUploads(bucketId, options) {
    return __async(this, null, function* () {
      if (options.skip < 0 || options.limit < 0) {
        throw new Error(`Skip and Limit cannot be negative numbers.`);
      }
      const { deployments } = yield this.spheronApi.getProjectDeployments(
        bucketId,
        {
          skip: options.skip && options.skip >= 0 ? options.skip : 0,
          limit: options.limit && options.limit >= 0 ? options.limit : 6
        }
      );
      return deployments.map((x) => this.mapDeploymentToUpload(x));
    });
  }
  getBucketUploadCount(bucketId) {
    return __async(this, null, function* () {
      return yield this.spheronApi.getProjectDeploymentCount(bucketId);
    });
  }
  archiveBucket(bucketId) {
    return __async(this, null, function* () {
      yield this.spheronApi.updateProjectState(
        bucketId,
        import_core.ProjectStateEnum.ARCHIVED
      );
    });
  }
  unarchiveBucket(bucketId) {
    return __async(this, null, function* () {
      yield this.spheronApi.updateProjectState(
        bucketId,
        import_core.ProjectStateEnum.MAINTAINED
      );
    });
  }
  getUpload(uploadId) {
    return __async(this, null, function* () {
      const deployment = yield this.spheronApi.getDeployment(uploadId);
      return this.mapDeploymentToUpload(deployment);
    });
  }
  mapProjectToBucket(project) {
    var _a;
    return {
      id: project._id,
      name: project.name,
      organizationId: project.organization,
      state: project.state,
      domains: (_a = project.domains) == null ? void 0 : _a.map(
        (x) => this.mapProjectDomainToBucketDomain(x)
      )
    };
  }
  mapProjectDomainToBucketDomain(domain) {
    return {
      id: domain._id,
      name: domain.name,
      link: domain.link,
      verified: domain.verified,
      bucketId: domain.projectId,
      type: domain.type
    };
  }
  mapDeploymentToUpload(deployment) {
    var _a, _b;
    return {
      id: deployment._id,
      protocolLink: deployment.sitePreview,
      buildDirectory: deployment.buildDirectory,
      status: deployment.status,
      memoryUsed: deployment.memoryUsed,
      bucketId: (_b = (_a = deployment.project) == null ? void 0 : _a._id) != null ? _b : deployment.project,
      protocol: deployment.protocol
    };
  }
};
var bucket_manager_default = BucketManager;

// src/index.ts
var import_core2 = require("@spheron/core");

// src/fs-payload-creator.ts
var import_fs = __toESM(require("fs"));
var import_form_data = __toESM(require("form-data"));
var import_path = __toESM(require("path"));
var createPayloads = (path2, payloadSize) => __async(void 0, null, function* () {
  const uploadContext = {
    payloads: new Array(),
    currentPayload: null,
    currentPayloadSize: 0,
    totalSize: 0
  };
  yield fillUploadContext(path2, "./", uploadContext, true, payloadSize);
  if (uploadContext.currentPayload) {
    uploadContext.payloads.push(uploadContext.currentPayload);
  }
  return {
    payloads: uploadContext.payloads,
    totalSize: uploadContext.totalSize
  };
});
var fillUploadContext = (pathToFile, rootPath, uploadContext, isRoot, payloadSize) => __async(void 0, null, function* () {
  const stat = yield import_fs.default.promises.stat(pathToFile);
  if (stat.isFile()) {
    const fileName = import_path.default.basename(pathToFile);
    processFile(
      pathToFile,
      rootPath + fileName,
      stat,
      uploadContext,
      payloadSize
    );
    return;
  }
  const files = yield import_fs.default.promises.readdir(pathToFile);
  for (const file of files) {
    yield fillUploadContext(
      `${pathToFile}/${file}`,
      isRoot ? "./" : `${rootPath}${import_path.default.basename(pathToFile)}/`,
      uploadContext,
      false,
      payloadSize
    );
  }
});
var processFile = (fullPath, uploadPath, stat, uploadContext, payloadSize) => __async(void 0, null, function* () {
  uploadContext.totalSize += stat.size;
  if (stat.size > payloadSize) {
    const numOfChunks = Math.ceil(stat.size / payloadSize);
    for (let i = 0; i < numOfChunks; i++) {
      const start = i * payloadSize;
      const end = start + payloadSize - 1;
      const form = new import_form_data.default();
      form.append(
        `chunk-${i}-${numOfChunks}`,
        import_fs.default.createReadStream(fullPath, { start, end }),
        {
          filepath: uploadPath
        }
      );
      uploadContext.payloads.push(form);
    }
  } else {
    if (!uploadContext.currentPayload) {
      uploadContext.currentPayload = new import_form_data.default();
    }
    uploadContext.currentPayload.append(
      "files",
      import_fs.default.createReadStream(fullPath),
      {
        filepath: uploadPath
      }
    );
    uploadContext.currentPayloadSize += stat.size;
    if (uploadContext.currentPayloadSize > payloadSize) {
      uploadContext.payloads.push(uploadContext.currentPayload);
      uploadContext.currentPayload = null;
      uploadContext.currentPayloadSize = 0;
    }
  }
});

// src/ipfs.utils.ts
var import_cid = require("multiformats/cid");
var ipfs = {
  utils: {
    toV0: (v1) => {
      const cid = import_cid.CID.parse(v1);
      if (cid.version === 0)
        return v1;
      return cid.toV0().toString();
    },
    toV1: (v0) => {
      const cid = import_cid.CID.parse(v0);
      if (cid.version === 1)
        return v0;
      return cid.toV1().toString();
    }
  }
};

// src/index.ts
var SpheronClient = class {
  constructor(configuration) {
    this.configuration = configuration;
    this.spheronApi = new import_core2.SpheronApi(this.configuration.token);
    this.bucketManager = new bucket_manager_default(this.spheronApi);
    this.uploadManager = new import_core2.UploadManager();
  }
  upload(path2, configuration) {
    return __async(this, null, function* () {
      const { deploymentId, payloadSize, parallelUploadCount } = yield this.uploadManager.initiateDeployment({
        protocol: configuration.protocol,
        name: configuration.name,
        organizationId: configuration.organizationId,
        token: this.configuration.token
      });
      const { payloads, totalSize } = yield createPayloads(path2, payloadSize);
      configuration.onUploadInitiated && configuration.onUploadInitiated(deploymentId);
      const uploadPayloadsResult = yield this.uploadManager.uploadPayloads(
        payloads,
        {
          deploymentId,
          token: this.configuration.token,
          parallelUploadCount,
          onChunkUploaded: (uploadedSize) => configuration.onChunkUploaded && configuration.onChunkUploaded(uploadedSize, totalSize)
        }
      );
      const result = yield this.uploadManager.finalizeUploadDeployment(
        deploymentId,
        uploadPayloadsResult.success,
        this.configuration.token
      );
      if (!result.success) {
        throw new Error(`Upload failed. ${result.message}`);
      }
      return {
        uploadId: result.deploymentId,
        bucketId: result.projectId,
        protocolLink: result.sitePreview,
        dynamicLinks: result.affectedDomains
      };
    });
  }
  createSingleUploadToken(configuration) {
    return __async(this, null, function* () {
      const { singleDeploymentToken } = yield this.uploadManager.initiateDeployment({
        protocol: configuration.protocol,
        name: configuration.name,
        token: this.configuration.token,
        createSingleDeploymentToken: true
      });
      return { uploadToken: singleDeploymentToken };
    });
  }
  getBucket(bucketId) {
    return __async(this, null, function* () {
      return yield this.bucketManager.getBucket(bucketId);
    });
  }
  getBucketDomains(bucketId) {
    return __async(this, null, function* () {
      return yield this.bucketManager.getBucketDomains(bucketId);
    });
  }
  getBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      return yield this.bucketManager.getBucketDomain(bucketId, domainIdentifier);
    });
  }
  addBucketDomain(bucketId, options) {
    return __async(this, null, function* () {
      return yield this.bucketManager.addBucketDomain(bucketId, options);
    });
  }
  updateBucketDomain(bucketId, domainIdentifier, options) {
    return __async(this, null, function* () {
      return yield this.bucketManager.updateBucketDomain(
        bucketId,
        domainIdentifier,
        options
      );
    });
  }
  verifyBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      return yield this.bucketManager.verifyBucketDomain(
        bucketId,
        domainIdentifier
      );
    });
  }
  deleteBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      return yield this.bucketManager.deleteBucketDomain(
        bucketId,
        domainIdentifier
      );
    });
  }
  archiveBucket(bucketId) {
    return __async(this, null, function* () {
      yield this.bucketManager.archiveBucket(bucketId);
    });
  }
  unarchiveBucket(bucketId) {
    return __async(this, null, function* () {
      yield this.bucketManager.unarchiveBucket(bucketId);
    });
  }
  publishIPNS(uploadId) {
    return __async(this, null, function* () {
      return yield this.spheronApi.publishIPNS(uploadId);
    });
  }
  updateIPNSName(ipnsNameId, uploadId) {
    return __async(this, null, function* () {
      return yield this.spheronApi.updateIPNSName(ipnsNameId, uploadId);
    });
  }
  getIPNSName(ipnsNameId) {
    return __async(this, null, function* () {
      return yield this.spheronApi.getIPNSName(ipnsNameId);
    });
  }
  getIPNSNamesForUpload(uploadId) {
    return __async(this, null, function* () {
      return yield this.spheronApi.getIPNSNamesForUpload(uploadId);
    });
  }
  getIPNSNamesForOrganization(organizationId) {
    return __async(this, null, function* () {
      return yield this.spheronApi.getIPNSNamesForOrganization(organizationId);
    });
  }
  getBucketUploadCount(bucketId) {
    return __async(this, null, function* () {
      return yield this.bucketManager.getBucketUploadCount(bucketId);
    });
  }
  getBucketUploads(bucketId, options) {
    return __async(this, null, function* () {
      return yield this.bucketManager.getBucketUploads(bucketId, options);
    });
  }
  getUpload(uploadId) {
    return __async(this, null, function* () {
      return yield this.bucketManager.getUpload(uploadId);
    });
  }
  getOrganizationUsage(organizationId) {
    return __async(this, null, function* () {
      const usage = yield this.spheronApi.getOrganizationUsage(
        organizationId,
        "wa-global"
      );
      const _a = usage, { usedStorageSkynet, storageSkynetLimit } = _a, resultWithoutSkynet = __objRest(_a, ["usedStorageSkynet", "storageSkynetLimit"]);
      return resultWithoutSkynet;
    });
  }
  getTokenScope() {
    return __async(this, null, function* () {
      return yield this.spheronApi.getTokenScope();
    });
  }
};
var src_default = SpheronClient;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DomainTypeEnum,
  IPNSName,
  ProtocolEnum,
  SpheronClient,
  TokenScope,
  UploadStatusEnum,
  UsageWithLimits,
  ipfs
});
